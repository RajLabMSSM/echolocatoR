% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/finemap_loci.R
\name{finemap_loci}
\alias{finemap_loci}
\title{Fine-map multiple loci}
\usage{
finemap_loci(
  loci = NULL,
  fullSS_path,
  fullSS_genome_build = NULL,
  results_dir = file.path(tempdir(), "results"),
  dataset_name = "dataset_name",
  dataset_type = "GWAS",
  topSNPs = "auto",
  force_new_subset = FALSE,
  force_new_LD = FALSE,
  force_new_finemap = FALSE,
  finemap_methods = c("ABF", "FINEMAP", "SUSIE"),
  finemap_args = NULL,
  n_causal = 5,
  credset_thresh = 0.95,
  consensus_thresh = 2,
  fillNA = 0,
  conditioned_snps = "auto",
  priors_col = NULL,
  munged = FALSE,
  colmap = echodata::construct_colmap(munged = munged),
  compute_n = "ldsc",
  LD_reference = "1KGphase3",
  LD_genome_build = "hg19",
  leadSNP_LD_block = FALSE,
  superpopulation = "EUR",
  download_method = "axel",
  bp_distance = 5e+05,
  min_POS = NA,
  max_POS = NA,
  min_MAF = NA,
  trim_gene_limits = FALSE,
  max_snps = NULL,
  min_r2 = 0,
  remove_variants = FALSE,
  remove_correlates = FALSE,
  query_by = "tabix",
  case_control = TRUE,
  qtl_suffixes = NULL,
  plot_types = c("simple"),
  show_plot = TRUE,
  zoom = "1x",
  tx_biotypes = NULL,
  nott_epigenome = FALSE,
  nott_show_placseq = FALSE,
  nott_binwidth = 200,
  nott_bigwig_dir = NULL,
  xgr_libnames = NULL,
  roadmap = FALSE,
  roadmap_query = NULL,
  remove_tmps = TRUE,
  conda_env = "echoR_mini",
  return_all = TRUE,
  use_tryCatch = TRUE,
  seed = 2022,
  nThread = 1,
  verbose = TRUE,
  top_SNPs = deprecated(),
  PP_threshold = deprecated(),
  consensus_threshold = deprecated(),
  plot.Nott_epigenome = deprecated(),
  plot.Nott_show_placseq = deprecated(),
  plot.Nott_binwidth = deprecated(),
  plot.Nott_bigwig_dir = deprecated(),
  plot.Roadmap = deprecated(),
  plot.Roadmap_query = deprecated(),
  plot.XGR_libnames = deprecated(),
  server = deprecated(),
  plot.types = deprecated(),
  plot.zoom = deprecated(),
  QTL_prefixes = deprecated(),
  vcf_folder = deprecated(),
  probe_path = deprecated(),
  file_sep = deprecated(),
  chrom_col = deprecated(),
  chrom_type = deprecated(),
  position_col = deprecated(),
  snp_col = deprecated(),
  pval_col = deprecated(),
  effect_col = deprecated(),
  stderr_col = deprecated(),
  tstat_col = deprecated(),
  locus_col = deprecated(),
  freq_col = deprecated(),
  MAF_col = deprecated(),
  A1_col = deprecated(),
  A2_col = deprecated(),
  gene_col = deprecated(),
  N_cases_col = deprecated(),
  N_controls_col = deprecated(),
  N_cases = deprecated(),
  N_controls = deprecated(),
  proportion_cases = deprecated(),
  sample_size = deprecated(),
  PAINTOR_QTL_datasets = deprecated()
)
}
\arguments{
\item{loci}{Character list of loci in \strong{Locus} col of \code{topSNPs}.}

\item{fullSS_path}{Path to the full summary statistics file (GWAS or QTL)
that you want to fine-map.
It is usually best to provide the absolute path rather
than the relative path.}

\item{fullSS_genome_build}{Genome build of the full summary statistics
 (\code{fullSS_path}). Can be "GRCH37" or "GRCH38" or one of their synonyms..
If \code{fullSS_genome_build==NULL} and \code{munged=TRUE},
infers genome build (hg19 vs. hg38)
from summary statistics using \link[MungeSumstats]{get_genome_builds}.}

\item{results_dir}{Where to store all results.
\strong{IMPORTANT!:} It is usually best to provide the absolute path
rather than the relative path.
This is especially important for \emph{FINEMAP}.}

\item{dataset_name}{The name you want to assign to the dataset
being fine-mapped,
This will be used to name the subdirectory where your
results will be stored
(e.g. \emph{Data/GWAS/<dataset_name>}).
Don't use special characters (e.g.".", "/").}

\item{dataset_type}{The kind dataset you're fine-mapping
(e.g. GWAS, eQTL, tQTL).
This will also be used when creating the subdirectory where your results
will be stored
(e.g. \emph{Data/<dataset_type>/Kunkle_2019}).}

\item{topSNPs}{A data.frame with the genomic coordinates of the lead SNP
for each locus.
The lead SNP will be used as the center of the window when extracting
subset from the full GWAS/QTL summary statistics file.
Only one SNP per \strong{Locus} should be included.
At minimum, \code{topSNPs} should include the following columns:
\describe{
\item{\emph{Locus}}{A unique name for each locus. Often,
 loci are named after a relevant gene (e.g. LRRK2) or based on
  the name/coordinates of the lead SNP (e.g. locus_chr12_40734202) }
\item{\emph{CHR}}{The chromosome that the SNP is on.
 Can be "chr12" or "12" format.}
\item{\emph{POS}}{The genomic position of the SNP (in basepairs)}
}}

\item{force_new_subset}{By default, if a subset of the full
 summary stats file for a given locus is already present,
then \pkg{echolocatoR} will just use the pre-existing file.
Set \code{force_new_subset=T} to override this and extract a new subset.
Subsets are saved in the following path structure:
\emph{Data/\<dataset_type\>/\<dataset_name\>/\<locus\>/Multi-finemap/
\<locus\>_\<dataset_name\>_Multi-finemap.tsv.gz}}

\item{force_new_LD}{Force new LD subset.}

\item{force_new_finemap}{By default, if an fine-mapping results file for
 a given locus is already present,
then \pkg{echolocatoR} will just use the preexisting file.
Set \code{force_new_finemap=T} to override this and re-run fine-mapping.}

\item{finemap_methods}{Which fine-mapping methods you want to use.}

\item{finemap_args}{A named nested list containing additional arguments 
for each fine-mapping method. e.g.
\code{finemap_args = list(FINEMAP=list(), PAINTOR=list(method=""))}}

\item{n_causal}{The maximum number of potential causal SNPs per locus.
This parameter is used somewhat differently by different fine-mapping tools.
See tool-specific functions for details.}

\item{credset_thresh}{The minimum fine-mapped posterior probability
 for a SNP to be considered part of a Credible Set.
For example, \code{credset_thresh=.95} means that all Credible Set SNPs
will be 95\% Credible Set SNPs.}

\item{consensus_thresh}{The minimum number of fine-mapping tools 
in which a SNP is in the Credible Set in order to be included in the 
"Consensus_SNP" column.}

\item{fillNA}{Value to fill LD matrix NAs with.}

\item{conditioned_snps}{Which SNPs to conditions on when fine-mapping
with (e.g. \emph{COJO}).}

\item{priors_col}{[Optional] Name of the a column in 
\code{dat} to extract SNP-wise prior probabilities from.}

\item{munged}{Whether \code{fullSS_path} have already been
standardised/filtered full summary stats
with \link[MungeSumstats]{format_sumstats}.
If \code{munged=FALSE} you'll need to provide the necessary
 column names to the \code{colmap} argument.}

\item{colmap}{Column name mappings in in \code{fullSS_path}. Must be a named
list. Can use \link[echodata]{construct_colmap} to assist with this. This
function can be used in two different ways:
\itemize{
\item{\code{munged=FALSE} : }{When \code{munged=FALSE},
 you will need to provide the necessary column names to the
 \code{colmap} argument (\emph{default}).}
 \item{\code{munged=TRUE} : }{ Alternatively, instead of filling out
 each argument in
\link[echodata]{construct_colmap}, you can simply set \code{munged=TRUE}
 if  \code{fullSS_path} has already been munged with
 \link[MungeSumstats]{format_sumstats}.
 }
}}

\item{compute_n}{How to compute per-SNP sample size (new column "N").\cr
If the column "N" is already present in \code{dat}, this column 
will be used to extract per-SNP sample sizes
and the argument \code{compute_n} will be ignored.\cr
If the column "N" is \emph{not} present in \code{dat}, one of the following 
options can be supplied to \code{compute_n}: 
\itemize{
\item{\code{0}: }{N will not be computed.}
\item{\code{>0}: }{If any number >0 is provided,
that value will be set as N for every row.
**Note**: Computing N this way is incorrect and should be avoided
if at all possible.}
\item{\code{"sum"}: }{N will be computed as:
cases (N_CAS) + controls (N_CON), so long as both columns are present}.
\item{\code{"ldsc"}: }{N will be computed as effective sample size:
Neff =(N_CAS+N_CON)*(N_CAS/(N_CAS+N_CON)) / mean((N_CAS/(N_CAS+N_CON))(N_CAS+N_CON)==max(N_CAS+N_CON))}.
\item{\code{"giant"}: }{N will be computed as effective sample size:
Neff = 2 / (1/N_CAS + 1/N_CON)}.
\item{\code{"metal"}: }{N will be computed as effective sample size:
Neff = 4 / (1/N_CAS + 1/N_CON)}.
}}

\item{LD_reference}{LD reference to use:
\itemize{
\item{"1KGphase1" : }{1000 Genomes Project Phase 1 (genome build: hg19).}
\item{"1KGphase3" : }{1000 Genomes Project Phase 3 (genome build: hg19).}
\item{"UKB" : }{Pre-computed LD from a British
European-decent subset of UK Biobank.
\emph{Genome build} : hg19}
\item{"<vcf_path>" : }{User-supplied path to a custom VCF file 
to compute LD matrix from.\cr
\emph{Accepted formats}: \emph{.vcf} / \emph{.vcf.gz} / \emph{.vcf.bgz}\cr
\emph{Genome build} : defined by user with \code{target_genome}.}
\item{"<matrix_path>" : }{User-supplied path to a pre-computed LD matrix   
\emph{Accepted formats}:  \emph{.rds} / \emph{.rda} / \emph{.csv} / 
\emph{.tsv} / \emph{.txt}\cr
\emph{Genome build} : defined by user with \code{target_genome}.}
}}

\item{LD_genome_build}{Genome build of the LD panel.
This is automatically assigned to the correct genome build for each
LD panel except when the user supplies custom vcf/LD files.}

\item{leadSNP_LD_block}{Only return SNPs within the same LD block
as the lead SNP (the SNP with the smallest p-value).}

\item{superpopulation}{Superpopulation to subset LD panel by
(used only if \code{LD_reference} is "1KGphase1" or "1KGphase3").
See \link[echoLD]{popDat_1KGphase1} and \link[echoLD]{popDat_1KGphase3}
for full tables of their respective samples.}

\item{download_method}{\itemize{
\item{\code{"axel"} : }{Multi-threaded}
\item{\code{"wget"} : }{Single-threaded}
\item{\code{"download.file"} : }{Single-threaded}
\item{\code{"internal"} : }{Single-threaded 
(passed to \link[utils]{download.file})}
\item{\code{"wininet"} : }{Single-threaded 
(passed to \link[utils]{download.file})}
\item{\code{"libcurl"} : }{Single-threaded 
(passed to \link[utils]{download.file})}
\item{\code{"curl"} : }{Single-threaded 
(passed to \link[utils]{download.file})}
}}

\item{bp_distance}{Distance around the lead SNP to include.}

\item{min_POS}{Minimum genomic position to include.}

\item{max_POS}{Maximum genomic position to include.}

\item{min_MAF}{Minimum Minor Allele Frequency (MAF) of SNPs to include.}

\item{trim_gene_limits}{If a gene name is supplied to this argument 
(e.g. \code{trim_gene_limits="BST"}), only SNPs within the gene body
 will be included.}

\item{max_snps}{Maximum number of SNPs to include.}

\item{min_r2}{Correlation threshold for \code{remove_correlates}.}

\item{remove_variants}{A list of SNP RSIDs to remove.}

\item{remove_correlates}{A list of SNPs.
If provided, all SNPs that correlates with these SNPs (at r2>=\code{min_r2})
will be removed from both \code{dat} and \code{LD} list items..}

\item{query_by}{Choose which method you want to use to extract
 locus subsets from the full summary stats file.
Methods include:
\describe{
\item{"tabix"}{Convert the full summary stats file in an indexed tabix file.
 Makes querying lightning fast after the initial conversion is done.
  (\emph{default})}
\item{"coordinates"}{Extract locus subsets using min/max genomic
coordinates with \emph{awk}.}
}}

\item{case_control}{Whether the summary statistics come from a case-control
study (e.g. a GWAS of having Alzheimer's Disease or not) (\code{TRUE})
or a quantitative study (e.g. a GWAS of height, or an eQTL) (\code{FALSE}).}

\item{qtl_suffixes}{If columns with QTL data is included in \code{dat},
you can indicate which columns those are with one or more string suffixes
(e.g. \code{qtl_suffixes=c(".eQTL1",".eQTL2")} to use the columns 
"P.QTL1", "Effect.QTL1", "P.QTL2", "Effect.QTL2").}

\item{plot_types}{Which kinds of plots to include.
Options:
\itemize{
\item{"simple"}{Just plot the following tracks: GWAS,
fine-mapping, gene models}
\item{"fancy"}{Additionally plot XGR annotation tracks
(XGR, Roadmap, Nott2019).}
' \item{"LD"}{LD heatmap showing the 10 SNPs surrounding the lead SNP.}
}}

\item{show_plot}{Print plot to screen.}

\item{zoom}{Zoom into the center of the locus when plotting
(without editing the fine-mapping results file).
You can provide either:
\itemize{
\item{The size of your plot window in terms of basepairs
(e.g. \code{zoom=50000} for a 50kb window)}.
\item{How much you want to zoom in (e.g. \code{zoom="1x"}
for the full locus, \code{zoom="2x"}
for 2x zoom into the center of the locus, etc.)}.
}
You can pass a list of window sizes (e.g. \code{c(50000,100000,500000)})
to automatically generate
multiple views of each locus.
This can even be a mix of different style inputs: e.g.
 \code{c("1x","4.5x",25000)}.}

\item{tx_biotypes}{Transcript biotypes to include in the gene model track. 
By default (\code{NULL}), all transcript biotypes will be included.
See \link[echoplot]{get_tx_biotypes} for a full list of 
all available biotypes}

\item{nott_epigenome}{Include tracks showing brain cell-type-specific 
epigenomic data from 
\href{https://doi.org/10.1126/science.aay0793}{Nott et al. (2019)}.}

\item{nott_show_placseq}{Include track generated by
\link[echoannot]{NOTT2019_plac_seq_plot}.}

\item{nott_binwidth}{When including Nott et al. (2019)
epigenomic data in the track plots,
adjust the bin width of the histograms.}

\item{nott_bigwig_dir}{Instead of pulling Nott et al. (2019)
 epigenomic data
from the \emph{UCSC Genome Browser}, use a set of local bigwig files.}

\item{xgr_libnames}{Passed to \link[echoplot]{XGR_plot}.
Which XGR annotations to check overlap with.
For full list of libraries see
\href{http://XGR_r-forge.r-project.org/#annotations-at-the-genomic-region-level}{
 here}.
 Passed to the \code{RData.customised} argument in \link[XGR]{xRDataLoader}.}

\item{roadmap}{Find and plot annotations from Roadmap.}

\item{roadmap_query}{Only plot annotations from Roadmap whose
metadata contains a string or any items from  a list of strings
(e.g. \code{"brain"} or \code{c("brain","liver","monocytes")}).}

\item{remove_tmps}{Whether to remove any temporary files
(e.g. FINEMAP output files) after the pipeline is done running.}

\item{conda_env}{Conda environment to use.}

\item{return_all}{Return a nested list of various the pipeline's outputs
including plots, tables, and file paths (default: \code{TRUE}).
If \code{FALSE}, instead only returns a single merged
 \link[data.table]{data.table} containing the results from all loci.}

\item{use_tryCatch}{If an error is encountered in one locus,
the pipeline will continue to try running the rest of the loci
 (default: \code{use_tryCatch=TRUE}). This avoid stopping all analyses due
 to errors that only affect some loci,
 but currently prevents debugging via traceback.}

\item{seed}{Set the seed for all functions where this is possible.}

\item{nThread}{Number of threads to parallelise saving across.}

\item{verbose}{Print messages.}

\item{top_SNPs}{[deprecated]}

\item{PP_threshold}{[deprecated]}

\item{consensus_threshold}{[deprecated]}

\item{plot.Nott_epigenome}{[deprecated]}

\item{plot.Nott_show_placseq}{[deprecated]}

\item{plot.Nott_binwidth}{[deprecated]}

\item{plot.Nott_bigwig_dir}{[deprecated]}

\item{plot.Roadmap}{[deprecated]}

\item{plot.Roadmap_query}{[deprecated]}

\item{plot.XGR_libnames}{[deprecated]}

\item{server}{[deprecated]}

\item{plot.types}{[deprecated]}

\item{plot.zoom}{[deprecated]}

\item{QTL_prefixes}{[deprecated]}

\item{vcf_folder}{[deprecated]}

\item{probe_path}{[deprecated]}

\item{file_sep}{[deprecated]}

\item{chrom_col}{[deprecated]}

\item{chrom_type}{[deprecated]}

\item{position_col}{[deprecated]}

\item{snp_col}{[deprecated]}

\item{pval_col}{[deprecated]}

\item{effect_col}{[deprecated]}

\item{stderr_col}{[deprecated]}

\item{tstat_col}{[deprecated]}

\item{locus_col}{[deprecated]}

\item{freq_col}{[deprecated]}

\item{MAF_col}{[deprecated]}

\item{A1_col}{[deprecated]}

\item{A2_col}{[deprecated]}

\item{gene_col}{[deprecated]}

\item{N_cases_col}{[deprecated]}

\item{N_controls_col}{[deprecated]}

\item{N_cases}{[deprecated]}

\item{N_controls}{[deprecated]}

\item{proportion_cases}{[deprecated]}

\item{sample_size}{[deprecated]}

\item{PAINTOR_QTL_datasets}{[deprecated]}
}
\value{
By default, returns a nested list containing grouped by locus names
(e.g. \code{BST1}, \code{MEX3C}). The results of each locus contain
 the following elements:
\itemize{
\item{\code{finemap_dat}}{ :  Fine-mapping results from all selected methods
 merged with the original summary statistics
 (i.e. \strong{Multi-finemap results}). }
\item{\code{locus_plot}}{ :  A nested list containing one or more
zoomed views of locus plots.}
\item{\code{LD_matrix}}{ :  The post-processed LD matrix used
for fine-mapping.}
\item{\code{LD_plot}}{ :  An LD plot (if used).}
\item{\code{locus_dir}}{ :  Locus directory results are saved in.}
\item{\code{arguments}}{ : A record of the arguments supplied to
\link[echolocatoR]{finemap_loci}.}
}
In addition, the following object summarizes the results
from all the locus-specific results:
\itemize{
\item{\code{merged_dat}}{ : A merged \link[data.table]{data.table}
 with all fine-mapping results from all loci.}
}
}
\description{
\pkg{echolocatoR} will automatically fine-map each locus.
Uses the \code{topSNPs} data.frame to define locus coordinates.
}
\examples{
topSNPs <- echodata::topSNPs_Nalls2019
fullSS_path <- echodata::example_fullSS(dataset = "Nalls2019")

res <- echolocatoR::finemap_loci(
  fullSS_path = fullSS_path,
  topSNPs = topSNPs,
  loci = c("BST1","MEX3C"),
  finemap_methods = c("ABF","FINEMAP","SUSIE"),
  dataset_name = "Nalls23andMe_2019",
  fullSS_genome_build = "hg19",
  bp_distance = 1000,
  munged = TRUE)
}
\seealso{
Other MAIN: 
\code{\link{finemap_locus}()}
}
\concept{MAIN}
